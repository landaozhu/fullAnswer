```js
const arr1 = [1, 2];
const arr2 = arr1;
arr2[1] = 3;
arr1; //[1,3]
arr2; //[1,3]
```

对引用类型进行赋值，发现一旦一方改变，另一方也会改变，之所以会产生这个问题，就是因为等号赋值只能赋值引用类型的地址。于是出现浅拷贝，那如何实现，方法就太多了，至少要记住三个

数组

```js
arr2 = [...arr1];
arr2 = arr1.concat();
arr2 = arr1.slice();
arr2 = Object.assign([], arr1);
arr2 = Array.from(arr1);
arr2 = arr1.map((item) => item);
```

对象

```js
obj2 = { ...obj1 };
obj2 = Object.assign({}, obj1);
```

for in

```js
obj2 = cloneShalow(obj1);
function cloneShalow(obj) {
  const res = Array.isArray(obj) ? [] : {};
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      res[key] = obj[key];
    }
  }
  return res;
}
```

但是如果 item 是引用类型，那么浅拷贝就解决不了了，这时候就得用深拷贝

方法一：JSON.parse(JSON.stringify(obj))  
`const b=JSON.parse(JSON.stringify(a))`  
缺陷：

- 会忽略 undefined
- 会忽略 symbol
- 函数、日期、正则对象都会出现问题
- 不能解决循环引用的对象  
  方法二：lodash 的深拷贝函数  
  方法三：自定义深拷贝函数

```js
function cloneDeep(obj) {
  if (typeof obj !== "object") {
    return obj;
  }
  let res = obj instanceof Array ? [] : {};
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      res[key] = typeof obj[key] === "object" ? DeepClone(obj[key]) : obj[key];
    }
  }
  return res;
}
```

## 参考

- [[javascript 核心-15] 手写完美深拷贝代码实现 🍌](https://juejin.cn/post/7247278895338913851?searchId=2023082916334189BDFEFFB35EBCACA828)
