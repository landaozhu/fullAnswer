# 掌握这几个常问的数据结构与算法，前端面试再也不用慌

## 栈

### 定义

栈是一种特殊的线性表，只能在栈顶进行操作，有先进后出的特性

### 实现

```js
/**
 * push(item:string) 添加元素到栈顶
 * pop():item 弹出栈顶元素
 * top():item 返回栈顶元素
 * isEmpty():boolean 判断是否为空
 * size():number 返回栈里元素的个数
 * clear() 清空栈
 */
class Stack {
  constructor() {
    this.items = [];
  }
  push(item) {
    this.items.push(item);
  }
  pop() {
    return this.items.pop();
  }
  isEmpty() {
    return this.items.length === 0;
  }
  top() {
    this.item[this.size() - 1];
  }
  size() {
    return this.items.length;
  }
  clear() {
    this.items = [];
  }
}
```

### 练习

#### 1.合法括号

括号成对出现，才能合法

```js
sdf(ds(ew(we)rw)rwqq)qwewe //合法
(sd(qwqw)sd(sd)) //合法
()()sd()(sd()fw))( //不不合法
```

实现

```js
function isLeaglBrackets(str) {
  const stack = new Stack();
  for (let i = 0; i < str.length; i++) {
    const item = str[i];
    if (item === "(") {
      stack.push(item);
    } else if (item === ")") {
      if (stack.isEmpty()) {
        return false;
      }
      stack.pop();
    }
  }
  return stack.isEmpty();
}
```

### 应用场景

- 浏览器历史记录：通过栈实现浏览器的前进后退功能
- 路由管理：在单页面应用（SPA）中，实现路由切换及页面状态管理
- 括号匹配：检查代码中括号是否合法
- 函数调用堆栈：实现函数调用时的上下文切换
- 表达式求值：解析和计算数学表达式
- JavaScript 事件循环：浏览器使用任务队列和调用栈实现异步操作

## 队列

### 定义

队列是一种特殊的线性表，只允许在队列的头部删除元素，在队列的尾部添加元素

### 实现

```js
class Queue {
  constructor() {
    this.items = [];
  }
  enqueue(item) {
    this.items.push(item);
  }
  dequeue() {
    return this.items.shift();
  }
  head() {
    return this.items[0];
  }
  size() {
    return this.items.length;
  }
  clear() {
    this.items = [];
  }
  isEmpty() {
    return this.items === 0;
  }
}
```

### 练习

#### 队列实现斐波那契约数

```js
/**
 * 思路：
 * 1.把两个1放到队列中
 * 2.使用while循环，用index计数，循环终止条件index<n-2
 * 3.dequeue方法删除头部的一个元素，得到元素delItem
 * 4.head方法得到headItem
 * 5.del+headItem放到队尾
 * 6.index++
 */
function fabonacci(n) {
  const queue = new Queue();
  if (n === 1 || n === 2) {
    return 1;
  }
  queue.enqueue(1);
  queue.enqueue(1);
  let index = 0;
  while (index < n - 2) {
    const delItem = queue.dequeue();
    const headItem = queue.head();
    queue.enqueue(delItem + headItem);
    index++;
  }
  queue.dequeue();
  return queue.head();
}
```

## 链表
